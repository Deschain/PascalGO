/* Seccion de opctiones */
options{
	IGNORE_CASE = true;
	VISITOR = true;
	MULTI = true;
	NODE_DEFAULT_VOID = true;
	NODE_PREFIX = "Node";	
}

/* Seccion de ejecucion */
PARSER_BEGIN(PascalGO)

	package pascalGO.grammar;
	
	/* Imports */		
	import java.util.ArrayList;
	import java.lang.NumberFormatException;
	import java.io.*;

	import pascalGO.table.*;
	import pascalGO.types.*;
	import pascalGO.error.*;

	//Definition of types
	
	public class PascalGO 
	{
	    //Definition of Basic Type ids.
		private static String INTEGER = "Integer";
		private static String BOOLEAN = "Boolean";

		//SymbolTable
		private static SymbolTable symbolTable = new SymbolTable();		

		//Main program
		public static void main (String[] argum) throws ParseException{


			//Code for Input management.
			java.io.InputStream istream = null;
			if (argum.length == 0) //No parameters, read from stdin			{
			    istream = System.in;			}else if (argum.length == 1) //One parameter, expected name of file, read from file			{
			    try			    {				    istream = new FileInputStream(argum[0]);
				}catch(FileNotFoundException e)//File does not exists				{
				System.out.println("Execution error:");
				System.out.println(e.getMessage());
			    System.out.println("Usage:");
			    System.out.println("	pascalGO");
			    System.out.println("	pascalGO filename");
			    return;				}
			}else //Incorrect number of parameters			{
			    System.out.println("Execution error:");
			    System.out.println("Usage:");
			    System.out.println("	pascalGO");
			    System.out.println("	pascalGO filename");
			    return;			}
			
		  SimpleNode tree = null;
			try{

				//Default types and Constants (Compiler types and constants)
				symbolTable.add(new Type("Integer"));
				symbolTable.add(new Type("Boolean"));
				symbolTable.add(new Constant("TRUE","1","Boolean"));
				symbolTable.add(new Constant("FALSE","0","Boolean"));

			    //Initialize the parser				PascalGO analizador = new PascalGO(istream);			
				tree = analizador.start();
				IntermediateCodeGenerator visitor = new IntermediateCodeGenerator();


	
				//Code Generation (Sintactic and semanic checks done during the parsing)
				visitor.visit(tree,null);
				System.out.println();
				//Completed with success
			}catch(PascalGOException e){
			    System.out.println(e.toString());			}catch(ParseException error){				
				  int[][] expectedTokens = error.expectedTokenSequences;
				  System.out.println("Error in "+PascalGO.token.beginLine+","+PascalGO.token.beginColumn);
				  System.out.print("Expecting: ");
				  for (int i = 0; i < expectedTokens.length; i++) {			    
				  	for (int j = 0; j < expectedTokens[i].length; j++) {
					        System.out.println(tokenImage[expectedTokens[i][j]]+' ');
					  }				  }
				  System.out.println("Received: "+error.currentToken.next.image.toLowerCase());
			}catch(Exception error){
				error.printStackTrace();			}
			return;
		}
	}
PARSER_END(PascalGO)

/* Seccion de sintaxis */
	
	SimpleNode start() #Programa:
	{}
	{
		programaCompleto()
		{			
			return jjtThis ;
		}
	}
	
	void programaCompleto():
	{ }
	{
		programa()<PUNTO>
		{
		    symbolTable.eraseLevel();		}
	}
	
	/* Regla 1 */
	void programa():
	{}
	{		
		<PROGRAM><ID><PUNTOYCOMA>
		{
		    symbolTable.openLevel();		}bloque()		
	}
	
	
	/* Regla 2 */
	void bloque():
	{}
	{
		declaracion()grupoSent()
	}
	
	/* Regla 3 */
	void declaracion():
	{}
	{
		[defCte()][defTip()][defVar()](defSubpr())*
	}
	
	/* Regla 4 */
	void defCte():
	{ }
	{	
		<CONST> (unaConst()<PUNTOYCOMA>)+
	}
	
	/* Regla 5 */
	/**
		This method evaluates the definition of a constant.
		There can be no elements with the same name
		The value must either be boolean ("TRUE" or "FALSE"), an integer, or another constant
	*/
	void unaConst():
	{
		Token constName;
		String constValue;
		BasicType bt = null;
		Constant constant = null;
	}
	{
		constName = <ID> <IGUAL> constValue = constante()
		{
			//boolean
			bt = symbolTable.localSearch(constName.image.toLowerCase());
			if (bt == null)			{
			    constant = new Constant(constName.image.toLowerCase(),constValue);
			    try			    {			        Integer.parseInt(constValue);
			        constant.setType("Integer");
			    }
			    catch(NumberFormatException e)			    {
			        bt = symbolTable.localSearch(constValue);
			   		if (bt != null)			   		{  
						if (!(bt instanceof Constant))
							throw new PascalGOException(bt.getName() + "is not a valid value for constant");
			    		constant.setType(((Constant)bt).getType());
			 		}			    }
				symbolTable.add(constant);
				//System.out.println("Constant definition "+constName.image.toLowerCase()+" with value "+constValue + " added");
			}
			else			{
			    throw new PascalGOException("Constant definition "+constName.image.toLowerCase()+" failed, id in use");
			}
		}
	}
	
	/* Regla 6 */
	void defTip():
	{}
	{
		<TYPE> 
		(untipo()<PUNTOYCOMA>)+
	}
	
	/* Regla 7 */
	void untipo():
	{
		Token typeName;
		Type type;
	}
	{
		typeName = <ID> <IGUAL> type = tipoEstr()
		{
			type.setName(typeName.image.toLowerCase());
			symbolTable.add(type);
		}
	}
	
	/* Regla 8 */
	Type tipoEstr():
	{
		Type type;
	}
	{
			type = estrTab()		{
			    return type;		}
	/* Regla 9 */
		|	type = estrReg()
		{
		    return type;		}
	}
	
	/* Regla 10 */
	Type estrTab():
	{
		String infRange, supRange;
		Token arrayType;
		ArrayType array = new ArrayType();
	}
	{
		<ARRAY> <CORCHETEIZ> infRange = constante() <RANGO> supRange = constante() <CORCHETEDE> <OF> arrayType = <ID>
		{
			//System.out.println("Type: Array, rangoInf "+infRange+", rangoSup "+supRange+", de tipo "+arrayType.image.toLowerCase());
			try			{
			    array.setRangoInferior(Integer.parseInt(infRange));			}catch(NumberFormatException e)			{
			    BasicType bt = symbolTable.totalSearch(infRange);
			    if ((bt != null) && (bt instanceof Constant))			    {
			        			    }else			    {
			        throw new PascalGOException(infRange + " is not a valid lower limit for an array");			    }			}

			try
			{
			    array.setRangoSuperior(Integer.parseInt(supRange));
			}catch(NumberFormatException e)
			{
			    BasicType bt = symbolTable.totalSearch(supRange);
			    if ((bt != null) && (bt instanceof Constant))
			    {
			        
			    }else
			    {
			        throw new PascalGOException(supRange + " is not a valid upper limit for an array");
			    }
			}

			if (array.getRangoSuperior() <= array.getRangoInferior())
				throw new PascalGOException("[" + array.getRangoInferior() + "," + array.getRangoSuperior() + "] isn't a valid range");
			
			if (symbolTable.has(arrayType.image.toLowerCase()))			{
				array.setType(arrayType.image.toLowerCase());
			}else			{
			    throw new PascalGOException(arrayType.image.toLowerCase() + " isn't a valid type");			}
			return array;
		}
	}
	
	/* Regla 11 */
	Type estrReg():
	{
		ArrayList<Variable> variables;
		RecordType record = new RecordType();
	}
	{
		<RECORD> 
		variables =  listaVar()
			{
				record.merge(variables);
			}
		(variables = listaVar()
			{
			    record.merge(variables);
			}
		<PUNTOYCOMA>)* <END>		{
		    return record;		}
	}
	
	/* Regla 12 */
	void defVar():
	{
		ArrayList<Variable> variables;
		String type;
		BasicType bt;
	}
	{
		<VAR> 
		(variables = listaVar()
			{
			    //Como comparten el typo, se comprueba una vez;
				bt = symbolTable.totalSearch(variables.get(0).getType());
			    if (bt != null && bt instanceof Type )
				for(Variable var : variables){
					//System.out.println("Declarada variable "+var.getName()+" del tipo "+var.getType());
					symbolTable.add(var);
				}
				
			}		
		<PUNTOYCOMA>)+
		
	}
	
	/* Regla 13 */
	void defSubpr() #Procedure:
	{
		Procedure proc;
		Token t;
		ArrayList <Variable > vars = null;
	}
	{
	<PROCEDURE> t=<ID>
		{jjtThis.jjtSetValue(t.image);}		{
			proc = new Procedure(t.image.toLowerCase());
			if (symbolTable.has(proc))
			 	throw new PascalGOException("Simbol for procedure " + t.image.toLowerCase() + "already exists.");			
			symbolTable.add(proc);
			symbolTable.openLevel();
			}
	[ <PARENTESISIZ> vars = parFormales() <PARENTESISDE> ] <PUNTOYCOMA> 
		{
		    if (vars != null)		    {			    proc.merge(vars);
		   		for(Variable var: proc.getParameters())		   		{		   		    symbolTable.add(var);		  		}
			}	  
		}	bloque() <PUNTOYCOMA>
		{
			//analizar semanticamente jjtThis
			//elmimiar nivel actual.
			symbolTable.eraseLevel();		}   
	}
	
	/* Regla 14 */
	ArrayList<Variable> parFormales():
	{
	    ArrayList <Variable> types;;
	    ArrayList <Variable> auxTypes;
	}
	{
		types = listaParam() (<PUNTOYCOMA> auxTypes= listaParam()			{
				if (auxTypes != null)
					types.addAll(auxTypes);			}
		)*
		{
		    return types;		}
	}
	
	/* Regla 15 */
	ArrayList<Variable> listaParam():
	{
		ArrayList<Variable> parameters;
	}
	{
		[<VAR>] parameters = listaVar()
		{
			return parameters;
		}
	}
	
	/* Regla 16 */
	ArrayList<Variable> listaVar():
	{
		Token t;
		ArrayList<Variable > variables = new ArrayList<Variable >();
		BasicType bt = null;
	}
	{
		t = <ID>
		{
		    if (symbolTable.localSearch(t.image.toLowerCase()) == null)
				variables.add(new Variable(t.image.toLowerCase()));
			else
				throw new PascalGOException(t.image.toLowerCase() +" id already in use");
		}
		(<COMA> 
		 	t = <ID>
			{
		    if (symbolTable.localSearch(t.image.toLowerCase().toLowerCase()) == null)
				variables.add(new Variable(t.image.toLowerCase().toLowerCase()));
			else
				throw new PascalGOException(t.image.toLowerCase().toLowerCase() +" id already in use");
			}
		)* 
		<DOSPUNTOS> t  = <ID>
		{
		    bt = symbolTable.totalSearch(t.image.toLowerCase());
		    if (bt == null)
		    	throw new PascalGOException("Type " + t.image.toLowerCase().toLowerCase() + " does not exist");
		    else
	    	{
		    	for (Variable s : variables)
		    		s.setType(t.image.toLowerCase());
		 	   return variables;
			}
		}
	}
	
	/* Regla 17 */
	void grupoSent()#Block:
	{}
	{
		<BEGIN> sentencia() (<PUNTOYCOMA> sentencia())* <END>
	}
	
	/* Regla 18 */
	void sentencia():
	{}
	{
		[
			asignLlamada() 	
	/* Regla 19 */
		|	condicional() 	
	/* Regla 20 */
		|	ciclica()
	/* Regla 21 */
		|	grupoSent()
	/* Regla 22 */
		]

	}
	
	/* Regla 23 */
	void asignLlamada() #Asignement:
	{
		BasicType type1 = null;
	}
	{
		type1 = identifier() restoAsignLlam(type1)
	}
	
	/* Regla 24 */
	void restoAsignLlam(BasicType bt):
	{
		Type expresionType = null;
	}
	{
		[
				<ASIGNACION> expresionType = expresion()				{
				    if (bt instanceof Procedure)
				    	throw new PascalGOException(bt.getName()+" is a procedure, cannot be assigned");
				   	if ((bt instanceof Variable) && (!((Variable)bt).getType().equals(expresionType.getName())))
				   		throw new PascalGOException(bt.getName()+" and " + expresionType.getName() + " not compatible");
				   	if (bt instanceof Constant)
				   		throw new PascalGOException(bt.getName()+" is a constant, cannot be assigned");				}
	/* Regla 25 */
			|	<PARENTESISIZ> [parLlamada(bt)] <PARENTESISDE>
		]
	/* Regla 26 */
	
	}
	
	/* Regla 27 */
	void condicional() #Conditional:
	{
		Type type = null;
	}
	{
		<IF> type = expresion()		{
		    if (!type.getName().toLowerCase().equals("boolean") )
		    	throw new PascalGOException("IF condition doesn't return a boolean value");		} <THEN> sentencia() [ LOOKAHEAD(2) <ELSE> sentencia()]
	}
	
	/* Regla 28 */
	void ciclica() #Loop:
	{
		Type type = null;
	}
	{
		<WHILE> expresion()		{
		    if (!type.getName().toLowerCase().equals("boolean") )
		    	throw new PascalGOException("WHILE condition doesn't return a boolean value");
		    		}<DO> sentencia()
	}
	
	/* Regla 29 */
	void parLlamada(BasicType p):
	{
		Type type = null;
		int contador = 0;
		Procedure proc = null;
	}
	{
		type = expresion()
		{
		    if (p instanceof Procedure)
				proc = (Procedure) p;
		    else
		    	throw new PascalGOException("Incompatible call with type " + p.getName());
		    if (!type.getName().equals(proc.getVariable(contador).getType()))
		    	throw new PascalGOException("Incompatible types for procedure "+ proc.getName() +"call on parameter "+ contador+1);		} ( <COMA> type = expresion()
		{
		    contador++;
		    if (!type.getName().equals(proc.getVariable(contador).getType()))
		    	throw new PascalGOException("Incompatible types for procedure "+ proc.getName() +"call on parameter "+ contador+1);		}
		)*
	}
	
	/* Regla 30 */
	Type expresion():
	{
		Type type1 = null;
		Type type2 = null;
	}
	{ 
		type1 = exprSimple() 
		[ 
		  opRel() type2 = exprSimple()
		  {
			  Node exp1,op,exp2;
			  exp2 = jjtree.popNode();
			  op   = jjtree.popNode();
			  exp1 = jjtree.popNode();
			  op.jjtAddChild(exp1,0);
			  op.jjtAddChild(exp2,1);
			  jjtree.pushNode(op);

			  if (!type1.equals(type2))
			  	throw new PascalGOException(exp1 +" and "+ exp2 + " are incompatible for operand" + op);
			  type1 = new Type("boolean");
		  }
		]
		{
			return type1;
		}
	}
	
	/* Regla 31 */
	Type exprSimple():
	{
		Node unaryOp = null;
		Type type1 = null;
		Type type2 = null;
		String o = null;
	}
	{
		[signo() {unaryOp = jjtree.popNode();}] 
		type1 =termino()
		{
			if(unaryOp != null){
				unaryOp.jjtAddChild(jjtree.popNode(),0);
				jjtree.pushNode(unaryOp);
			}
		}
		( 
			o = opAdt() type2 = termino()
			{
				  Node term1,op,term2;
				  term2 = jjtree.popNode();
				  op    = jjtree.popNode();
				  term1 = jjtree.popNode();
				  op.jjtAddChild(term1,0);
				  op.jjtAddChild(term2,1);
				  jjtree.pushNode(op);

				  if (!type1.getName().toLowerCase().equals(type2.getName().toLowerCase()))
				  	throw new PascalGOException("Incompatible types \""+ type1.getName() +"\" \""+ type2.getName() +"\" for operand " + op);
				if (o.toLowerCase().equals("or"))
				{
				  	if (!type1.getName().toLowerCase().equals("boolean"))
				  		throw new PascalGOException("Incompatible types for and operation");
				}
				else
				if (!type1.getName().toLowerCase().equals("integer"))
					throw new PascalGOException("Incompatible types for" + o);

				type1 = type2;
			}
		)*
		{
			return type1;
		}
	}
	
	/* Regla 32 */
	Type termino():
	{
		Type type1 = null;
		Type type2 = null;
		String o = null;
	}
	{
		type1 = factor() 
		( 
			o = opMul() type2 = factor()
			{
			    
				  Node fac1,op,fac2;
				  fac2 = jjtree.popNode();
				  op    = jjtree.popNode();
				  fac1 = jjtree.popNode();
				  op.jjtAddChild(fac1,0);
				  op.jjtAddChild(fac2,1);
				  jjtree.pushNode(op);
				  
				if (!type1.getName().toLowerCase().equals(type2.getName().toLowerCase()))
				  	throw new PascalGOException("Incompatible types \""+ type1.getName() +"\" \""+ type2.getName() +"\" for operand " + op);
				if (o.toLowerCase().equals("and"))				{
				  	if (!type1.getName().toLowerCase().equals("boolean"))
				  		throw new PascalGOException("Incompatible types for and operation");
				}
				else
				if (!type1.getName().toLowerCase().equals("integer"))
					throw new PascalGOException("Incompatible types for" + o);

				type1 = type2;
			}
		)*
		{		    return type1;
		}
	}
	
	/* Regla 33 */
	Type factor():
	{
		Token t;
		BasicType bt = null;
		Type type = null;	
	}
	{
			t = <CTE> 
			{jjtThis.jjtSetValue(t.image.toLowerCase());
			return new Type("Integer");}
			#Constant		
	/* Regla 34 */
		|	bt = identifier()		{
		    if (bt instanceof Variable)
		    	return new Type(((Variable)bt).getType());
		   	else
		   		return new Type(bt.getName());
		    		}
	/* Regla 35 */	
		| 	<NOT> 			
			type = factor()			{
			    if (!type.getName().toLowerCase().equals("boolean"))
			    	throw new PascalGOException("Operand \"NOT\" not compatible with type " + type.getName());
			    return type;			}	
	/* Regla 36 */
		|	<PARENTESISIZ> type = expresion() <PARENTESISDE>
		{
		    return type;		}
	}
	
	/* Regla ajena a la gramatica para tratar identificadores de tipos complejos */
	BasicType identifier() #Identifier:
	{
		Token t;
		Node selector, aux;
		BasicType variableType = null;
		BasicType typeType = null;
		String auxType = null;
	}
	{
		t = <ID>
		{
			jjtThis.jjtSetValue(t.image.toLowerCase());
			aux = jjtThis;
			//Semantic
			variableType = symbolTable.totalSearch(t.image.toLowerCase());
			if (variableType == null)
				throw new PascalGOException (t.image.toLowerCase() + " first use of this id");
			else			{
			    
				if (variableType instanceof Constant)				{
					variableType = symbolTable.totalSearch(((Constant)variableType).getType());
				}else				typeType = symbolTable.totalSearch(((Variable)variableType).getType());			}    			
		}
		(
			auxType = selector(((Type)typeType))
			{
			    if (!(typeType instanceof ArrayType) && !(typeType instanceof RecordType))
			    	throw new PascalGOException (variableType.getName() + " the type doesnt accept selector operand");
				variableType = typeType;
			   	typeType = symbolTable.totalSearch(auxType);
				selector = jjtree.popNode();
				aux.jjtAddChild(selector,0);
				aux = selector;
			}
		)*
		{
		    return variableType;		}
	}

	/* Regla 38 */
	String selector(Type parentType) #Selector:
	{
		Token t;
		Variable var = null;
		Type auxType = null;
	}
	{
			<CORCHETEIZ> 
			auxType = expresion()
			{
			    jjtThis.jjtSetValue(jjtree.popNode());
			    if (!(parentType instanceof ArrayType))			    {
			        throw new PascalGOException("\"[ ]\" operator not valid for " +parentType.getName());			    }
			    else
			    {
			        if (auxType.getName().equals("integer"))
			        	return ((ArrayType)parentType).getType();
			        else
			        	throw new PascalGOException("Expresion inside [ ] does not return integer type");
			        return null;			    }
			}
			<CORCHETEDE>			
	/* Regla 39 */
		|	<PUNTO>  t = <ID>
			{
			    jjtThis.jjtSetValue(t.image.toLowerCase());
			    if (!(parentType instanceof RecordType))			    {
			        throw new PascalGOException("\".\" operator not valid for " + parentType.getName());			    }
			    else
			    {
			        var = ((RecordType)parentType).getVariable(t.image.toLowerCase());
			        if (var != null)
			        	return var.getType();
			        else
			        	throw new PascalGOException("Field " + t.image.toLowerCase() + " is not declared in " + parentType.getName());
			        return null;			    }
			}
	}
	
	/* Regla 40 */
	String constante():
	{
		String constant;
		SimpleNode sign;
	}
	{
		[ 
		  signo()
		  {
			  sign = (SimpleNode)jjtree.popNode();		  
		  }
		] 
		constant = cteSinSigno()
		{
			return constant;
		}
		
	}
	
	/* Regla 41 */
	/* Constants with out sign, used to define constants and into the array range definition*/
	String  cteSinSigno():
	{
		Token constValue;
	}
	{
		(constValue = <ID> | constValue = <CTE>)
		{
			return constValue.image.toLowerCase();
		}
	}
	
	/* Regla 42 */
	void opRel() #opRel:
	{}
	{
			<MAYOR> 	{jjtThis.value = ">";}
		|	<MAYORIG>	{jjtThis.value = ">=";}
		|	<MENOR>		{jjtThis.value = "<";}
		|	<MENORIG>	{jjtThis.value = "<=";}
		|	<IGUAL>		{jjtThis.value = "=";}
		|	<DESIGUAL>	{jjtThis.value = "<>";}
	}
	
	/* Regla 43 */
	String opAdt() #opAdt:
	{		
	}
	{	
			<SUMA>  {jjtThis.value = "+"; return "+";}
		| 	<RESTA> {jjtThis.value = "-"; return "-";}
		| 	<OR> 	{jjtThis.value = "OR"; return "OR";}	
	}
	
	/* Regla 44 */
	String opMul() #opMul:
	{}
	{
			<MULT> 	{jjtThis.value = "*"; return "*";}
		|	<DIV>	{jjtThis.value = "DIV"; return "DIV";}
		|	<MOD>	{jjtThis.value = "MOD"; return "MOD";}
		|	<AND>	{jjtThis.value = "AND"; return "AND";}
	}
	
	/* Regla 45 */
	void signo() #Signo:
	{}
	{
			<SUMA>	{jjtThis.value = "+";}
		|	<RESTA>	{jjtThis.value = "-";}
	}
	
/* Seccion de lexico */
	/* Faltan por identificar los comentarios, y un repaso a los tokens que utilizan ER */

/* Caracteres que se omiten */
	SKIP:{
	  " "
	  | "\r"
	  | "\t"
	  | "\n"
	  | <MULTI_LINE_COMMENT:"{"(~["}"])*"}">
	  | <MULTI:"(""*"(~["*"])*"*"")">
	}

/* Palabras reservadas */
	TOKEN:{
			<AND: 	"and">
		|	<ARRAY: "array">
		|	<BEGIN:	"begin">
		|	<CONST: "const">
		|	<DIV:	"div">
		|	<DO:	"do">
		|	<ELSE:	"else">
		|	<END:	"end"> 
		|	<IF:	"if">
		|	<MOD:	"mod">
		|	<NOT:	"not">
		|	<OF:	"of">
		|	<OR:	"or">
		|	<PROCEDURE:	"procedure">
		|	<PROGRAM:	"program">
		|	<RECORD:	"record">
		|	<THEN:	"then">
		|	<TYPE:	"type">	
		|	<VAR:	"var">
		|	<WHILE:	"while">
	}

/* Operadores aritmeticos */
	TOKEN:{
	  	<SUMA:	"+">
	  |	<RESTA:	"-">
	  |	<MULT:	"*">
	}

/* Operadores relacionales */
	TOKEN:{
	 	<MAYOR:		">">
	 |	<MAYORIG:	">=">
	 |	<MENOR:		"<">
	 |	<MENORIG:	"<=">
	 |	<IGUAL:		"=">
	 |	<DESIGUAL:	"<>">
	}

/* Asignacion */
	TOKEN:{
	  <ASIGNACION:	":=">
	}

/* Signos de puntuacion */
	TOKEN:{
	  	<PARENTESISIZ:	"(">
	  |	<PARENTESISDE:	")">
	  |	<CORCHETEIZ:	"[">
	  |	<CORCHETEDE:	"]">
	  |	<COMA:			",">
	  |	<PUNTOYCOMA:	";">
	  |	<PUNTO:			".">
	  |	<DOSPUNTOS:		":">
	}


/* Rango */
	TOKEN:{
	  <RANGO:		"..">
	}
	
/* Identificador */
	TOKEN:{
  		<ID: ["a"-"z"](["a"-"z","0"-"9"])*>
	}
	
/* Constante */
	TOKEN:{
			<CTE: ["1"-"9" ,"0"](["0"-"9"])* >
	}