/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. pascalGO.jj */
/*@egen*//* Seccion de opctiones */
options{
	IGNORE_CASE = true;
	               
	             
	                         
	                     	
}

/* Seccion de ejecucion */
PARSER_BEGIN(PascalGO)

	package pascalGO.grammar;
	
	/* Imports */		
	import pascalGO.table.*;		

	public class PascalGO/*@bgen(jjtree)*/implements PascalGOTreeConstants/*@egen*/ 
	{/*@bgen(jjtree)*/
  protected static JJTPascalGOState jjtree = new JJTPascalGOState();

/*@egen*/
		private static SymbolTable symbolTable = new SymbolTable();	
		
		public static void main (String[] argum) throws ParseException
		{
		
		  SimpleNode tree = null;
			try{				PascalGO analizador = new PascalGO(System.in);			
				//Llamar al metodo que reconoce la primera expresion del sintactico
				tree = analizador.start();
				IntermediateCodeGenerator visitor = new IntermediateCodeGenerator();
				//visitor.visit(tree,null);
				tree.dump("");
				//Mensajes de salida como exito
				//System.out.println("Todo ha ido bien");		
			}catch(ParseException error){				
				  int[][] expectedTokens = error.expectedTokenSequences;
				  System.out.println("Error en "+PascalGO.token.beginLine+","+PascalGO.token.beginColumn);
				  System.out.print("Se esperaba: ");
				  for (int i = 0; i < expectedTokens.length; i++) {			    
				  	for (int j = 0; j < expectedTokens[i].length; j++) {
					        System.out.println(tokenImage[expectedTokens[i][j]]+' ');
					  }				  }
				  System.out.println("Y se ha recibido: "+error.currentToken.next.image);
				  //tree.dump("");			   			  
			}catch(Exception error){
				error.printStackTrace();			}			
		}
	}
PARSER_END(PascalGO)

/* Seccion de sintaxis */
	
	SimpleNode start()          :
	{/*@bgen(jjtree) Programa */
  NodePrograma jjtn000 = new NodePrograma(JJTPROGRAMA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Programa */
                try {
/*@egen*/
		programaCompleto()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{			
			return jjtn000 ;
		}/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}
	
	void programaCompleto():
	{ }
	{
		programa()<PUNTO>
	}
	
	/* Regla 1 */
	void programa():
	{}
	{		
		<PROGRAM><ID><PUNTOYCOMA>bloque()		
	}
	
	
	/* Regla 2 */
	void bloque():
	{}
	{
		declaracion()grupoSent()
	}
	
	/* Regla 3 */
	void declaracion():
	{}
	{
		[defCte()][defTip()][defVar()](defSubpr())*
	}
	
	/* Regla 4 */
	void defCte():
	{ }
	{	
		<CONST> (unaConst()<PUNTOYCOMA>)+
	}
	
	/* Regla 5 */
	void unaConst():
	{}
	{
		<ID> <IGUAL> constante()		
	}
	
	/* Regla 6 */
	void defTip():
	{}
	{
		<TYPE> (untipo()<PUNTOYCOMA>)+
	}
	
	/* Regla 7 */
	void untipo():
	{}
	{
		<ID> tipoEstr()
	}
	
	/* Regla 8 */
	void tipoEstr():
	{}
	{
			estrTab()
	/* Regla 9 */
		|	estrReg()
	}
	
	/* Regla 10 */
	void estrTab():
	{}
	{
		<ARRAY> <CORCHETEIZ> constante() <RANGO> constante() <CORCHETEDE> <OF> <ID>
	}
	
	/* Regla 11 */
	void estrReg():
	{}
	{
		<RECORD> listaVar() (listaVar() <PUNTOYCOMA>)* <END>
	}
	
	/* Regla 12 */
	void defVar():
	{}
	{
		<VAR> (listaVar()<PUNTOYCOMA>)+
	}
	
	/* Regla 13 */
	void defSubpr()           :
	{/*@bgen(jjtree) Procedure */
  NodeProcedure jjtn000 = new NodeProcedure(JJTPROCEDURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Procedure */
                try {
/*@egen*/
		<PROCEDURE> <ID> [ <PARENTESISIZ> parFormales()<DOSPUNTOS> <PARENTESISDE> ] <PUNTOYCOMA> bloque() <PUNTOYCOMA>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}
	
	/* Regla 14 */
	void parFormales():
	{}
	{
		listaParam() (<PUNTOYCOMA> listaParam())*
	}
	
	/* Regla 15 */
	void listaParam():
	{}
	{
		[<VAR>] listaVar()
	}
	
	/* Regla 16 */
	void listaVar():
	{}
	{
		<ID> (<COMA><ID>)* <DOSPUNTOS> <ID>
	}
	
	/* Regla 17 */
	void grupoSent():
	{}
	{
		<BEGIN> sentencia() (<PUNTOYCOMA> sentencia())* <END>
	}
	
	/* Regla 18 */
	void sentencia():
	{}
	{
		[
			asignLlamada() 	
	/* Regla 19 */
		|	condicional() 	
	/* Regla 20 */
		|	ciclica()
	/* Regla 21 */
		|	grupoSent()
	/* Regla 22 */
		]

	}
	
	/* Regla 23 */
	void asignLlamada()            :
	{/*@bgen(jjtree) Asignement */
  NodeAsignement jjtn000 = new NodeAsignement(JJTASIGNEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Asignement */
                try {
/*@egen*/
		identifier() restoAsignLlam()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}
	
	/* Regla 24 */
	void restoAsignLlam():
	{}
	{
		[
				<ASIGNACION> expresion()
	/* Regla 25 */
			|	<PARENTESISIZ> parLlamada() <PARENTESISDE>
		]
	/* Regla 26 */
	}
	
	/* Regla 27 */
	void condicional()             :
	{/*@bgen(jjtree) Conditional */
  NodeConditional jjtn000 = new NodeConditional(JJTCONDITIONAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Conditional */
                try {
/*@egen*/
		<IF> expresion() <THEN> sentencia() [<ELSE> sentencia()]/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}
	
	/* Regla 28 */
	void ciclica()      :
	{/*@bgen(jjtree) Loop */
  NodeLoop jjtn000 = new NodeLoop(JJTLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Loop */
                try {
/*@egen*/
		<WHILE> expresion() <DO> sentencia()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}
	
	/* Regla 29 */
	void parLlamada():
	{}
	{
		expresion() ( <COMA> expresion() )*
	}
	
	/* Regla 30 */
	void expresion():
	{}
	{ 
		exprSimple() 
		[ 
		  opRel() exprSimple()
		  {
			  Node exp1,op,exp2;
			  exp2 = jjtree.popNode();
			  op   = jjtree.popNode();
			  exp1 = jjtree.popNode();
			  op.jjtAddChild(exp1,0);
			  op.jjtAddChild(exp2,1);
			  jjtree.pushNode(op);
		  }
		] 
	}
	
	/* Regla 31 */
	void exprSimple():
	{
		Node unaryOp = null;
	}
	{
		[signo() {unaryOp = jjtree.popNode();}] 
		termino()
		{
			if(unaryOp != null){
				unaryOp.jjtAddChild(jjtree.popNode(),0);
				jjtree.pushNode(unaryOp);
			}
		}
		( 
			opAdt() termino()
			{
				  Node term1,op,term2;
				  term2 = jjtree.popNode();
				  op    = jjtree.popNode();
				  term1 = jjtree.popNode();
				  op.jjtAddChild(term1,0);
				  op.jjtAddChild(term2,1);
				  jjtree.pushNode(op);
			}
		)*
	}
	
	/* Regla 32 */
	void termino():
	{}
	{
		factor() 
		( 
			opMul() factor()
			{
				  Node fac1,op,fac2;
				  fac2 = jjtree.popNode();
				  op    = jjtree.popNode();
				  fac1 = jjtree.popNode();
				  op.jjtAddChild(fac1,0);
				  op.jjtAddChild(fac2,1);
				  jjtree.pushNode(op);
			}
		)*
	}
	
	/* Regla 33 */
	void factor():
	{
		Token t;		
	}
	{
			t = <CTE>/*@bgen(jjtree) Constant */
                        {
                          NodeConstant jjtn001 = new NodeConstant(JJTCONSTANT);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*//*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{jjtn001.jjtSetValue(t.image);}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                          }
                        }
/*@egen*/
			         		
	/* Regla 34 */
		|	identifier()
	/* Regla 35 */	
		| 	<NOT>/*@bgen(jjtree) Negacion */
                        {
                          NodeNegacion jjtn002 = new NodeNegacion(JJTNEGACION);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/ 
			factor()/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, true);
                          }
                        }
/*@egen*/
			                                            
			         
	/* Regla 36 */
		|	<PARENTESISIZ> expresion() <PARENTESISDE>
	}
	
	/* Regla ajena a la gramatica para tratar identificadores de tipos complejos */
	void identifier()            :
	{/*@bgen(jjtree) Identifier */
                NodeIdentifier jjtn000 = new NodeIdentifier(JJTIDENTIFIER);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/
		Token t;
		Node selector, aux;
	}
	{/*@bgen(jjtree) Identifier */
                try {
/*@egen*/
		t = <ID>
		{
			jjtn000.jjtSetValue(t.image);
			aux = jjtn000;			
		}
		(
			selector()
			{
				selector = jjtree.popNode();
				aux.jjtAddChild(selector,0);
				aux = selector;
			}
		)*/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

	/* Regla 38 */
	void selector()          :
	{/*@bgen(jjtree) Selector */
                NodeSelector jjtn000 = new NodeSelector(JJTSELECTOR);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/
		Token t; 
	}
	{/*@bgen(jjtree) Selector */
                        try {
/*@egen*/
			<CORCHETEIZ> 
			expresion()
			{jjtn000.jjtSetValue(jjtree.popNode());}
			<CORCHETEDE>			
	/* Regla 39 */
		|	<PUNTO>  t = <ID>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
			{jjtn000.jjtSetValue(t.image);}/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
                        }
/*@egen*/
	}
	
	/* Regla 40 */
	void constante()          :
	{/*@bgen(jjtree) Constant */
  NodeConstant jjtn000 = new NodeConstant(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Constant */
                try {
/*@egen*/
		[ signo() ] cteSinSigno()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
		
	}
	
	/* Regla 41 */
	void  cteSinSigno():
	{}
	{
			<ID> 
		|	<CTE>
	}
	
	/* Regla 42 */
	void opRel()       :
	{/*@bgen(jjtree) opRel */
  NodeopRel jjtn000 = new NodeopRel(JJTOPREL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) opRel */
                        try {
/*@egen*/
			<MAYOR>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/ 	{jjtn000.value = ">";}
		|	<MAYORIG>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/	{jjtn000.value = ">=";}
		|	<MENOR>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/		{jjtn000.value = "<";}
		|	<MENORIG>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/	{jjtn000.value = "<=";}
		|	<IGUAL>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/		{jjtn000.value = "=";}
		|	<DESIGUAL>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/	{jjtn000.value = "<>";}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
                        }
/*@egen*/
	}
	
	/* Regla 43 */
	void opAdt()       :
	{/*@bgen(jjtree) opAdt */
  NodeopAdt jjtn000 = new NodeopAdt(JJTOPADT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/		
	}
	{/*@bgen(jjtree) opAdt */
                        try {
/*@egen*/	
			<SUMA>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/  {jjtn000.value = "+";}
		| 	<RESTA>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ {jjtn000.value = "-";}
		| 	<OR>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ 	{jjtn000.value = "OR";}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
                        }
/*@egen*/	
	}
	
	/* Regla 44 */
	void opMul()       :
	{/*@bgen(jjtree) opMul */
  NodeopMul jjtn000 = new NodeopMul(JJTOPMUL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) opMul */
                        try {
/*@egen*/
			<MULT>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ 	{jjtn000.value = "*";}
		|	<DIV>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{jjtn000.value = "div";}
		|	<MOD>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{jjtn000.value = "mod";}
		|	<AND>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{jjtn000.value = "and";}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
                        }
/*@egen*/
	}
	
	/* Regla 45 */
	void signo()       :
	{/*@bgen(jjtree) Signo */
  NodeSigno jjtn000 = new NodeSigno(JJTSIGNO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
	{/*@bgen(jjtree) Signo */
                        try {
/*@egen*/
			<SUMA>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{jjtn000.value = "+";}
		|	<RESTA>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{jjtn000.value = "-";}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                          }
                        }
/*@egen*/
	}
	
/* Seccion de lexico */
	/* Faltan por identificar los comentarios, y un repaso a los tokens que utilizan ER */

/* Caracteres que se omiten */
	SKIP:{
	  " "
	  | "\r"
	  | "\t"
	  | "\n"
	}

/* Palabras reservadas */
	TOKEN:{
			<AND: 	"and">
		|	<ARRAY: "array">
		|	<BEGIN:	"begin">
		|	<CONST: "const">
		|	<DIV:	"div">
		|	<DO:	"do">
		|	<ELSE:	"else">
		|	<END:	"end"> 
		|	<IF:	"if">
		|	<MOD:	"mod">
		|	<NOT:	"not">
		|	<OF:	"of">
		|	<OR:	"or">
		|	<PROCEDURE:	"procedure">
		|	<PROGRAM:	"program">
		|	<RECORD:	"record">
		|	<THEN:	"then">
		|	<TYPE:	"type">	
		|	<VAR:	"var">
		|	<WHILE:	"while">
	}

/* Operadores aritmeticos */
	TOKEN:{
	  	<SUMA:	"+">
	  |	<RESTA:	"-">
	  |	<MULT:	"*">
	}

/* Operadores relacionales */
	TOKEN:{
	 	<MAYOR:		">">
	 |	<MAYORIG:	">=">
	 |	<MENOR:		"<">
	 |	<MENORIG:	"<=">
	 |	<IGUAL:		"=">
	 |	<DESIGUAL:	"<>">
	}

/* Asignacion */
	TOKEN:{
	  <ASIGNACION:	":=">
	}

/* Signos de puntuacion */
	TOKEN:{
	  	<PARENTESISIZ:	"(">
	  |	<PARENTESISDE:	")">
	  |	<CORCHETEIZ:	"[">
	  |	<CORCHETEDE:	"]">
	  |	<COMA:			",">
	  |	<PUNTOYCOMA:	";">
	  |	<PUNTO:			".">
	  |	<DOSPUNTOS:		":">
	}


/* Rango */
	TOKEN:{
	  <RANGO:		"..">
	}
	
/* Identificador */
	TOKEN:{
  		<ID: ["a"-"z"](["a"-"z","0"-"9"])*>
	}
	
/* Constante */
	TOKEN:{
			<CTE: ["1"-"9" ,"0"](["0"-"9"])* >
	}